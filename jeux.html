<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
  <link rel="stylesheet" href="style.css" type="text/css" media="all" />
</head>

<body>
  <div class="menu-button" onclick="toggleMenu()">
    <span></span>
    <span></span>
    <span></span>
  </div>

  <!-- Menu lat√©ral -->
  <nav class="menu" id="menu">
    <a href="index.html">Accueil</a>
    <a href="statistiques.html">Statistiques</a>
    <a href="jeux.html">Jeux</a>
    <a href="contact.html">Contact</a>
  </nav>
  
    <h1>Loto Pr√©diction</h1>
    <hr />
    <button id="download-btn">PREDICTION</button>
    <div id="result"></div>
    
    <a href="turbo.html">TURBO 2</a>
    <script>
      const predictBtn = document.getElementById('download-btn');
const resultDiv = document.getElementById('result');

// Dur√©e d'attente : 2 heures (en ms)
const cooldownDuration = 2 * 60 * 60 * 1000;

// V√©rifie s'il y a d√©j√† une date de dernier clic stock√©e
let lastPredictionTime = localStorage.getItem('lastPredictionTime');
let clickCount = 0;

// G√©n√®re un nombre al√©atoire entre min et max
function generateRandomNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// G√©n√®re 4 num√©ros al√©atoires uniques
function predictNumbers() {
    let numbers = [];
    for (let i = 0; i < 4; i++) {
        let num = generateRandomNumber(1, 90);
        while (numbers.includes(num)) {
            num = generateRandomNumber(1, 90);
        }
        numbers.push(num);
    }
    return numbers;
}

// Met √† jour le compte √† rebours toutes les secondes
function startCountdown(remainingTime) {
    predictBtn.disabled = true;
    const interval = setInterval(() => {
        remainingTime -= 1000;
        if (remainingTime <= 0) {
            clearInterval(interval);
            predictBtn.disabled = false;
            resultDiv.innerHTML = "Vous pouvez g√©n√©rer une nouvelle pr√©diction.";
            return;
        }
        const hours = Math.floor(remainingTime / (1000 * 60 * 60));
        const minutes = Math.floor((remainingTime % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((remainingTime % (1000 * 60)) / 1000);
        resultDiv.innerHTML = `‚è≥ Nouvelle pr√©diction possible dans : ${hours}h ${minutes}m ${seconds}s`;
    }, 1000);
}

// √âcoute du bouton
predictBtn.addEventListener('click', () => {
    clickCount++;
    if (clickCount === 1) {
        const predictions = predictNumbers();
        resultDiv.innerHTML = `üéØ ${predictions.join(' - ')}<br>Bonne chance √† vous !`;
    } else if (clickCount >= 2) {
        const now = Date.now();
        lastPredictionTime = localStorage.getItem('lastPredictionTime');
        if (lastPredictionTime && now - lastPredictionTime < cooldownDuration) {
            const remainingTime = cooldownDuration - (now - lastPredictionTime);
            startCountdown(remainingTime);
        } else {
            startCountdown(cooldownDuration);
            localStorage.setItem('lastPredictionTime', now);
        }
    }
});

// Si une pr√©diction existe d√©j√†, d√©marre le compte √† rebours au rechargement de la page
if (lastPredictionTime) {
    const now = Date.now();
    const elapsed = now - lastPredictionTime;
    if (elapsed < cooldownDuration) {
        startCountdown(cooldownDuration - elapsed);
        clickCount = 2; // Pour prendre en compte le cooldown existant
    }
}

function toggleMenu() {
      const menu = document.getElementById('menu');
      const button = document.querySelector('.menu-button');
      menu.classList.toggle('active');
      button.classList.toggle('active');
                              }
    </script>
</body>

</html>
